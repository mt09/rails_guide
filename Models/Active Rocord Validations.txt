Active Record Validations

This guide teaches you how to validate the state of objects before they go into the database using Active Record's validations feature.

After reading this guide, you will know:

How to use the built-in Active Record validation helpers.
how to create your own custom validation methods.
How to work with the error messages generated by the validaton process.


1 Validation Overview

Here's an example of a very simple validation: 

[code]
class Person < ApplictionRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => ture
Person.create(name: nil).valid? # => false
[/code]


As you can see, our validation lets us know that our Person is no valid without a name attribute. The second Person will not be persisted to the database.

Before we dig into more details, let's talk about how validations fit into the big picture of your application.

如你所見，藉由驗證可以知道Person在沒有name屬性時不通過驗證，第二筆Person也就不會接續下去。
了解更多細節之前，先來看看應用程式如何驗證。



1.1 Why Use Validation?

Validations are used to ensure that only valid data is saved into your database. For example, it may be important to your application to ensure that every user provides a valid email address and mailing address. Model-level validations are the best way to ensure that only valid data is saved into your database. They are database agnostic, cannot be bypassed by end users, and are convenient to test and maintain. Rails makes them easy to use, provides built-in helpers for common needs, and allows you to create your own validation methods as well.

驗證常用做確保符合規格的資料存入資料庫。確保每一位使用者提供了合格的email與收件地址，對應用程式而言相當重要。Model層級的驗證是最好的方式以確保唯有合格資料方能存入資料庫。不論何種資料庫，用戶端無法避開，且易於測試與維護。Rails提供內建helper做廣泛使用，也可自訂驗證方法。


There are several other ways to validate data before it is saved into your database, including native database constraints, client-side validations and controller-level validations. Here's a summary of the pros and cons:

·Database constraints and/or stored procedures make the validation mechanisms database-dependent and can make testing and maintenance more diffcult. However, if your database is used by other applications, it may be a good idea to use some constraints at the database level. Additionally, database-level validations can safely handle some things(such as uniqueness in heavily-used tables) that can be diffcult to implement otherwise.

·Client-side validations can be useful, but are generally unreliable if used alone. If they are implemented using JavaScript, they may be bypassed if JavaScript is turned off in the user's browser. However, if combined with other techniques, client-side validation can be a convenient way to provide users with immediate feedback as they use your site.

·Controller-level validations can be tempting to use, but often become unwieldy and diffcult to test and maintain. Whenever possible, it's a good idea to keep your controllers skinny, as it will make your application a pleasure to work with in the long run.


存入資料庫前可以用許多方式進行驗證，包含原生資料庫限制，客戶端驗證，controller層級驗證，優劣如下：

·資料庫限制與預存程序(stored procedure)使驗證機制與資料庫相依，且測試維護難上加難。若資料庫在其他應用程式運作，在資料庫層級做限制會比較好。此外，資料庫層級的驗證可以安全地處理某些部分(重度使用的table中檢查uniqueness)，在其他部分處理會變得困難。

·客戶端驗證有用，但單獨使用時不受用。若實作中使用JavaScript，只要關上JavaScript就能繞過驗證。結合其他技術，客戶端驗證才會成為便於提供使用者即時的回饋。

·Controller層級驗證很誘人使用，但通常會笨重且難於測試及維護。盡量保持controller輕巧，才能讓應用程式運作長久。


Choose these in certain, specific cases. It's the opinion of the Rails team that model-level validations are the most appropriate in most circumstances.

適時使用，Rails團隊的觀點是model層級驗證是最符合眾多場景的方式。



1.2 When Does Validation Happen?

There are two kinds of Active Record objects: those that correspond to a row inside your database and those that do not. When you create a fresh object, for example using the new method, that object does not belong to the database yet. Once you call save upon that object it will be saved into the appropriate database table. Active Record uses the new_record? instance method to detemine whether an object is already in the database or not. Consider the following simple Active Record class: 

在此有兩類Active Record物件：對應資料庫內的列與否。新物件的建立，使用new方法，物件還不屬於資料庫。自開始呼叫save起，物件將被存入合適的資料庫表格。Active Record使用 new_record? 實例方法以決定一物件是否已存在於資料庫。

[code]
class Person < ActiveRecord::Base
end
[/code]


We can see how it works by looking at some rails console output:

由rails console可以得知它是如何運作：

[code]
$ bin/rails console
>> p = Person.new(name: "John Doe")
=> #<Person id: nil, name: "Jogn Doe", created_at: nil, updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
[/code]


Creating and saving a new record will send an SQL INSERT operation to the database. Updating an existing record will send an SQL UPDATE operation instesd. Validations are typically run before these commands are sent to the database. If any validations fail, the object will be marked as invalid and Active Record will not perform the INSERT or UPDATE operation. This avoids storing an invalid object in the database. You can choose to have specific validations run when an object is created, saved, or updated.

建立與儲存一新記錄後會對資料庫做一次SQL INSERT。更新現有記錄則是做SQL UPDATE。驗證一般來說會在存進資料庫前執行，若驗證失敗，物件將會註記上不合格且Active Record也不會執行INSERT與UPDATE，避免非合法物件存進資料庫。可以指定物件在產生、存入或者更新實作驗證。


warning:
There are many ways to change the state of an object in the database. Some methods will trigger validatons, but some will not. This means that it's possible to save an object in the database in an invalid state if you aren't careful.

在資料庫裡有許多改變物件狀態的方式。部分方法會觸發驗證。這代表著不合法的資料也可能存入資料庫。


The following methods trigger validations, and will save the object to the database only if the object is valid:

以下方法會觸發驗證且唯有經驗證後合法物件方能存入資料庫。

· create
· create!
· save
· save!
· update
· update!


The bang versions(eg. save!) raise an exception if the record is invalid. The non-bang versions don't: save and update return false, and create just returns the object.

爆炸式會在不合法記錄時提出例外。無爆炸式則在save與update會返回失敗，create時會返回物件。


1.3 Skipping Validations

The following methods skip validations, and will save the object to the database regardless of its validity. They should be used with caution.

下列方法略過驗證且在不知其正確性之下存入資料庫，請小心使用。

· decrement!
· decrement_counter
· increment!
· increment_counter
· toggle!
· touch
· update_all
· update_attribute
· update_column
· update_columns
· update_counters


Note that save also has the ability to skip validations if passed validate: false as an argument. This technique be used with caution.

要是使用validate: false參數，save方法也會略過驗證，一樣服用時請多留意。

· save(validate: false)


1.4 valid? and invalid?

Before saving an Active Record object, Rails runs your validations. If these validations produce any errors, Rails does not save the object.

You can also run these validations on your own. valid? triggers your validations and returns true if no errors were found in the object, and false otherwise. As you saw above:

儲存Active Record物件以前，Rails會執行驗證，若驗證出錯，Rails不會儲存出錯物件。

valid?會觸發驗證並在沒有錯誤時回傳true，反之則回傳false。

[code]
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "Tom Cruise").valid? # -> true
Person.create(name: nil).valid? # => false
[/code]


After Active Record has performed validations, any errors found can be accessed through the errors.messages instance method, which returns a collection of errors. By definition, an object is valid if this collection is empty after running validations.

在Active Record進行驗證後，任何錯誤都可以透過error.message這實例方法找到，它會回傳錯誤集合。依定義來看，單一合法物件是為驗證後錯誤為空集合。


Note that an object instantiated with new will not report errors even if it's technically invalid, because validations are automatically run only when the object is saved, such as with the create or save methods.

一物件實例化後，new方法將不會告知錯誤訊息，即便這是技術上的錯誤，因為驗證只會在物件被存入時自動執行，就如create或save方法。

[code]
class Person < ApplicationRecord
  validates :name, presence: true
end

>> p = Person.new
# => #<Person id: nil, name: nil>
>> p.errors.messages
# => {}

>> p.valid?
# => false
>> p.errors.messages
# => {name:["can't be blank"]}

>> p = Person.create
# => #<Person id: nil, name: nil>
>> p.errors.messages
# => {name:["can't be blank"]}

>> p.save
# => false

>> p.save!
# => ActiveRecord:RecordInvalid: Validation failed: Name can't be blank

>> Person.create!
# => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
[/code]


invalid? is simply the inverse of valid?. It triggers your validations, returning true if any errors were found in the object, and false otherwise.

invalid? 純粹是valid? 的相反，驗證物件有錯誤時回傳true，反之是false。


1.5 errors[]

To verify whether or not a particular attribute of an object is valid, you can use errors[:attribute]. It returns an array of all the errors for :attribute. If there are no errors on the specified attribute, an empty array is returned.

This method is only useful after validations have been run, because it only inspects the errors collection and does not trigger validations itself. It's different from the ActiveRecord::Base#invalid? method explained above because it doesn't verify the validity of the object as a whole. It only checks to see whether there are errors found on an individual attribute of the object.

驗證物件屬性是否合格，可以用errors[:attribute]。他會回傳所有錯誤的陣列回:attribute。若指定的attribute沒有錯誤，陣列為空。

該方法只用在驗證執行後，因為單檢查錯誤集合且不會觸發驗證。與ActiveRecord::Base#invalid?差異如前述，整體來說，他並不確認物件的合法性。單純確認是否在物件單一屬性有錯誤。


[code]
class Person < ApplicationRecord
  validates :name, presence: true
end

>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => false
[/code]


1.6 errors.details

To check which validations failed on an valid attribute, you can use errors.details[:attribute]. It returns an array of hashes with an :error key to get the symbol of the validator:

對一合格屬性進行驗證錯誤的確認，使用errors.details[:attribute]，它會回傳hash陣列，裡頭的key與value為:error與經驗證的symbol。

[code]
class Person < ApplicationRecord
  validates: name, presence: true
end

>> person = Person.new
>> person.valid?
>> person.errors.details[:name] # => [{error: :blank}]
[/code]



2 Validation Helpers

Active Record offers many pre-defined validation helpers that you can use directly inside your class definitions. These helpers provide common validation rules. Every time a validation falls, an error message is added to the object's errors collection, and this message is associated with the attribute being validated.

Each helper accepts an arbitrary number of attribute names, so with a single line of code you can add the same kind of validation to several attributes.

All ot them accept the :on and :message options, which define when the validation should be run and what message should be added to errors collection if it fall, respectively. The :on option takes one of the values :create or :update. There is a default error message for each one of the validation helpers. These messages are used when the :message option isn't specified. Let's take a look at each one of the available helpers.

Active Record提供眾多預先定義的驗證helper，直接用在class中的定義。這些helper提供常用的驗證規則。每當驗證失敗，錯誤訊息會加到物件的錯誤集合之中，而這錯誤訊息關聯著經驗證的屬性。

每個helper允許一個任意的數之於屬性名稱，所以可以在單行程式對多屬性進行同類驗證。

他們皆可用:on與:message來定義，:on用在:create或:update，每筆驗證helper有一個預設錯誤訊息。這些訊息在:message未被指定時使用。


2.1 acceotance

This method validates that a checkbox on the user interface was checked when a form was submitted. This is typically used when the user needs to agree to your application's terms of service, confirm that some text is read, or any similar concept.

驗證為表單送出已勾選的checkbox，通常用在使用者需要同意應用程式的服務條款，確認文字已讀或是類似概念。

[code]
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: true
end
[/code]

This check is performed only if terms_of_service is not nil. The default error message for this helper is "must be accepted". You can also pass custom message via the message option.

這項驗證在於terms_of_service不是nil時。預設錯誤訊息為："must be accepted"。也可以夠過message來傳入自訂訊息。

[code]
class Person < ApplicationRecord
  validates :terms_of_service, acceptance { message: 'must be abided' }
end
[/code]

It also receive an :accept option, which determines the allowed values that will be considered as accepted. It defaults to ['1'. true] and can be easily changed.

:accpet會讓許可數值作為接受，預設是['1', true]，易於修改。

[code]
class Person < ApplicationRecord
  validates :trems_of_service, acceptance: { accept: 'yes' }
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end
[/code]

This validation is very specific to web applications and this 'acceptance' does not need to be recorded anywhere in your database. If you don't have a field for it, the helper will just create a virtual attribute. If the field does exist in your database, the accept option must be set to or include true or else the validation will not run.

此驗證針對web應用程式，'acceptance'不需存入資料庫。若沒有對應欄位，helper會建立一虛擬屬性。若資料庫沒有該欄位，accept選項則需設定或是包含true，否則不會執行，



2.2 validates_associated

You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, valid? will be called upon each one of the associated objects.

關聯Model需要驗證時，可以使用此helper。存取物件時，會以valide?呼叫每個關聯物件。

[code]
class Library < ApplicationRecord
  has_many :books
  validates_associated :books
end
[/code]

The validation will work with all of the association types.
此驗證將會作用在所有關聯類型。

warning: Dont's use validates_associated on both ends of your associations. They would call each other in an infinite loop.
別將此heloer用在兩個關聯，他會呼叫每個物件並進入無窮迴圈。

The default error message for validates_associated is "is invalid". Note that each associated object will contain its own errors collection; errors do not bubble up to the calling model.

預設錯誤訊息為"is invalid"。每個關聯物件有自己的錯誤集合，錯誤不會出現在呼叫的model。



2.3 confirmation

Ypu should use this helper when you have two text field that should receive exactly the same content. For eample, you may want to confirm an email address or a password. This validation creates a virtual attribute whose name is the name of the field that has to be confirm with "_confirmation" appended.

confirmation的使用情境是兩個文字輸入框應收到相同內容，例如確認email或是密碼。這項驗證建立虛擬屬性，驗證的屬性名加上"_confirmation"。

[code]
class Person < ApplicationRecord
  validates :email, confirmtion: true
end
[/code]

In your view template you could use something like
在view使用如下

[code]
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
[/code]

This check is performed only if email_confirmation is not nil. To require confirmation, make sure to add a presence check for the confirmation attribute (we'll take a look at presence later on in this guide):

此確認唯有在email_confirmation為非nil。需要確認時，確保加上presence給confirmation屬性：

[code]
class Person < ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
[/code]

There is also a :case_sensitive option that you can use to define whether the confirmation constraint will be case sensitive or not. This option defaults to true.

:case_sensitive選項可以讓confirmation去限制大小寫，預設為true。

[code]
class Person < ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end
[/code]

The default error message for this helper is "doesn't match confirmation".

預設錯誤訊息為"doesn't match confirmation"。



2.4 exclusion

This helper validates that the attributes' values are not included in a given set. In fact, this set can be any enumerable object.

此項helper在於屬性值不包括在特定集合，可以是任何可列舉的物件。

[code]
class Account < ApplicationRecord
  validates :subdomain, exclusion: { in: %w(www us ca jp), message: "%{value} is reserved." }
end
[/code]

The exclusion helper has an option :in that receives the set of values that will not be accepted for the validated attributes. The :in ption has an alisa called :within that you can use for the same purpose. If you'd like to. This example uses the :message option to show how you can include the attribute's value. For full options to the message argument please see the message documentation.

The default error message is "is reserved".

exclusion helper可以使用:in選項來接收不被驗證的屬性值。:in有別稱:within，用途相同。此例使ㄥˋ:message選項顯示如何取得屬性值。

預設錯誤訊息："is reserved"。



2.5 format

This helper validates the attributes' values by testing whether they match a given regular expression, which is specified using the :with option.

此helper透過是否符合:with內容的正規表示式來驗證屬性值，

[code]
class Product < ApplicationRecord
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/, message: "only allows letters" }
end
[/code]

Alternatively, you can require that the specified attribute does not match the reqular expression by using the :without option.

The default error message is "is invalid".

換句話說，你可用:without來指定不符合正規表示式的屬性。

預設錯誤訊息是"is invalid"。



2.6 inclusion

This helper validates that the attributes values are included in a given set. In fact, this set can be any enumerable object.

此helper驗證包含在集合內的屬性值，集合是可以被列舉的物件。

[code]
class Coffee < ApplcationRecord
  validates :size, inclusion: { in: %w(small medium, large), message: "%{value} is not a valid size" }
end
[/code]

This inclusion helper has an option :in that receives the set of values that will be accepted. The :in option has an alias called :within that you can use for the same purpose, if you'd like to. The previous example uses the :message option to show how you can include the attribute's value. For full options please see the message documentation.

The default error message for this helper is "in not included in the list".

inclusion helper有:in選項接收將被許可的值。:in選項又可被稱作:within，用途相同。上例使用:message選項來取得屬性值。



2.7 length

This heloer validates the length of the attribute's values. It provides a variety of options, so you can specify length constraint in different ways:

[code]
class Person < ApplicationRecord
  validates :name, length: { minimum: 2 }
  validates :bio, length: {maximum: 500}
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
[/code]

The possible length constraint options are:

:minimum - The attribute cannot have less than the specified length. 
屬性不得少於指定長度。

:maxumum - The attribute cannot have more than the specified length.
屬性不得多於指定長度。

:in(or :within) - The attribute length must be included in a given interval. The value for this option must be a range.
屬性長度必須包含指定區間，值必須是一個範圍。

:is - The attribute length must be equal to the given value.
屬性長度需等於指定值。

The default error message depend on the type of length validation being performed. You can personalize these messages using the :wrong_length, :too_long, and :too_short options and %{count} as a placeholder for the number corresponding to the length constraint being used. you can still use the :message option to specify an error message.

預設錯誤訊息取決於驗證長度的結果。可以:wrong_length個人化訊息，:too_long、:too_short以及%{count}可比做placeholder給予數量對應到長度限制。一樣可用:message來指定錯誤訊息。

[code]
class Person < ApplocationRecord
  validates :bit, length: { maximum: 1000, to_long: "%{count} caracters is the maxumum allowed" }
end
[/code]

Note that the default error messages are plural (e.g., "is too short (minimum is %{count} characters)"). For this reason, when :minimum is 1 you should provide a personalized message or use presence: true instead. When :in or :within have lower limit of 1, you should either provide a personalized message or call presence prior to length.

留意預設錯誤訊息是複數("is too short (minimumis %{count} characters)")。於此，當:minimum為1，應提供個人化訊及或使用presence: true取代。使用:in、:within限制小於1，也應提供個人化訊息或presence。



2.8 numericality

This helper validates that your attribures have only numeric values. By default, it will match an optional sign followed by an integral or floating point number. To specify that only integral numbers are allowed set :only_integer to true.

此helper驗證屬性是為數字。預設它將符合可選擇的正負號加上整數或小樹。指定整數則設定:only_integer為true。

[code]
/\A[+-]?\d+\z/
[/code]

regular expression to validate the attribute's value. Ohterwise, it will try to convert the value to a number usign Float.

正規表示式驗證屬性值質，否則它會使用Float嘗試轉換值為數字。

[code]
class Player < ApplicationRecord
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end
[/code]

Besides :only_integer, this helper also accepts the following options to add constraintes to accetpable values:

此外，這項helper允許以下選項來限制可接受值：

:greater_than - Specifies the value must be greater than the supplied value. The default error message for this option is "must be greater than %{count}".

:greater_than_or_equal_to - Specifies the value must be greater than or equal to the supplied value. The default error message for this option is "must be greater than or equal to %{count}".

:equal_to - Specifies the value must be equal to the supplied value. The default error message for this option is "must be equal to %{count}".

:less_than - Specifies the value must be less than the supplied value. The default error message for this option is "must be less than %{count}".

:less_than_or_equal_to - Specifies the value must be less than or equal to the supplied value. The default error message for this option is "must be less than or equal %{count}".

:other_than - Specifies the value must be other than the supplied value. The default error message for this option is "must be otherthan %{count}".

:odd - Specifies the value must be an odd number if set to true. The default error message for this option is "must be odd".

:even - Specifies the value must be an even number if set to true. The default error message for this option is "must be even".

指定值必大於屬性值，預設錯誤訊息為"must be greater than %{count}"。

指定值必大於或等於屬性值，預設錯誤訊息為"must be greater than or equal to %{count}"。

指定值必等於屬性值，預設錯誤訊息為"must be equl to %{count}"。

指定值必小於屬性值，預設錯誤訊息為"must be less than to %{count}"。

指定值必小於或等於屬性值，預設錯誤訊息為"must be less than or equal to %{count}"。

指定值必不等於屬性值，預設錯誤訊息為"must be other than to %{count}"。

若設定為true，指定值必等於奇數，預設錯誤訊息為"must be odd"。

若設定為true，指定值必等於偶數，預設錯誤訊息為"must be even"。


Note: 
By default, numericality doesn't allow nil values. You can use allow_nil: true option to permit it.
預設不接受nil，可用allow_nil: true來允許接受nil。

The default error message is "is not a number".
預設錯誤訊息為"is not a number"。



2.9 presence

This helper validates that the specified attributes are not empty. It uses the blank? method to check if th value is either nil or a blank string, that is, a string that is either empty or consists of whitespace.

