Active Record Validations

This guide teaches you how to validate the state of objects before they go into the database using Active Record's validations feature.

After reading this guide, you will know:

How to use the built-in Active Record validation helpers.
how to create your own custom validation methods.
How to work with the error messages generated by the validaton process.



1 Validation Overview

Here's an example of a very simple validation: 

[code]
class Person < ApplictionRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => ture
Person.create(name: nil).valid? # => false
[/code]


As you can see, our validation lets us know that our Person is no valid without a name attribute. The second Person will not be persisted to the database.

Before we dig into more details, let's talk about how validations fit into the big picture of your application.

如你所見，藉由驗證可以知道Person在沒有name屬性時不通過驗證，第二筆Person也就不會接續下去。
了解更多細節之前，先來看看應用程式如何驗證。



1.1 Why Use Validation?

Validations are used to ensure that only valid data is saved into your database. For example, it may be important to your application to ensure that every user provides a valid email address and mailing address. Model-level validations are the best way to ensure that only valid data is saved into your database. They are database agnostic, cannot be bypassed by end users, and are convenient to test and maintain. Rails makes them easy to use, provides built-in helpers for common needs, and allows you to create your own validation methods as well.

驗證常用做確保符合規格的資料存入資料庫。確保每一位使用者提供了合格的email與收件地址，對應用程式而言相當重要。Model層級的驗證是最好的方式以確保唯有合格資料方能存入資料庫。不論何種資料庫，用戶端無法避開，且易於測試與維護。Rails提供內建helper做廣泛使用，也可自訂驗證方法。


There are several other ways to validate data before it is saved into your database, including native database constraints, client-side validations and controller-level validations. Here's a summary of the pros and cons:

·Database constraints and/or stored procedures make the validation mechanisms database-dependent and can make testing and maintenance more diffcult. However, if your database is used by other applications, it may be a good idea to use some constraints at the database level. Additionally, database-level validations can safely handle some things(such as uniqueness in heavily-used tables) that can be diffcult to implement otherwise.

·Client-side validations can be useful, but are generally unreliable if used alone. If they are implemented using JavaScript, they may be bypassed if JavaScript is turned off in the user's browser. However, if combined with other techniques, client-side validation can be a convenient way to provide users with immediate feedback as they use your site.

·Controller-level validations can be tempting to use, but often become unwieldy and diffcult to test and maintain. Whenever possible, it's a good idea to keep your controllers skinny, as it will make your application a pleasure to work with in the long run.


存入資料庫前可以用許多方式進行驗證，包含原生資料庫限制，客戶端驗證，controller層級驗證，優劣如下：

·資料庫限制與預存程序(stored procedure)使驗證機制與資料庫相依，且測試維護難上加難。若資料庫在其他應用程式運作，在資料庫層級做限制會比較好。此外，資料庫層級的驗證可以安全地處理某些部分(重度使用的table中檢查uniqueness)，在其他部分處理會變得困難。

·客戶端驗證有用，但單獨使用時不受用。若實作中使用JavaScript，只要關上JavaScript就能繞過驗證。結合其他技術，客戶端驗證才會成為便於提供使用者即時的回饋。

·Controller層級驗證很誘人使用，但通常會笨重且難於測試及維護。盡量保持controller輕巧，才能讓應用程式運作長久。


Choose these in certain, specific cases. It's the opinion of the Rails team that model-level validations are the most appropriate in most circumstances.

適時使用，Rails團隊的觀點是model層級驗證是最符合眾多場景的方式。



1.2 When Does Validation Happen?

There are two kinds of Active Record objects: those that correspond to a row inside your database and those that do not. When you create a fresh object, for example using the new method, that object does not belong to the database yet. Once you call save upon that object it will be saved into the appropriate database table. Active Record uses the new_record? instance method to detemine whether an object is already in the database or not. Consider the following simple Active Record class: 

在此有兩類Active Record物件：對應資料庫內的列與否。新物件的建立，使用new方法，物件還不屬於資料庫。自開始呼叫save起，物件將被存入合適的資料庫表格。Active Record使用 new_record? 實例方法以決定一物件是否已存在於資料庫。

[code]
class Person < ActiveRecord::Base
end
[/code]


We can see how it works by looking at some rails console output:

由rails console可以得知它是如何運作：

[code]
$ bin/rails console
>> p = Person.new(name: "John Doe")
=> #<Person id: nil, name: "Jogn Doe", created_at: nil, updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
[/code]


Creating and saving a new record will send an SQL INSERT operation to the database. Updating an existing record will send an SQL UPDATE operation instesd. Validations are typically run before these commands are sent to the database. If any validations fail, the object will be marked as invalid and Active Record will not perform the INSERT or UPDATE operation. This avoids storing an invalid object in the database. You can choose to have specific validations run when an object is created, saved, or updated.

建立與儲存一新記錄後會對資料庫做一次SQL INSERT。更新現有記錄則是做SQL UPDATE。驗證一般來說會在存進資料庫前執行，若驗證失敗，物件將會註記上不合格且Active Record也不會執行INSERT與UPDATE，避免非合法物件存進資料庫。可以指定物件在產生、存入或者更新實作驗證。


warning:
There are many ways to change the state of an object in the database. Some methods will trigger validatons, but some will not. This means that it's possible to save an object in the database in an invalid state if you aren't careful.

在資料庫裡有許多改變物件狀態的方式。部分方法會觸發驗證。這代表著不合法的資料也可能存入資料庫。


The following methods trigger validations, and will save the object to the database only if the object is valid:

以下方法會觸發驗證且唯有經驗證後合法物件方能存入資料庫。

· create
· create!
· save
· save!
· update
· update!


The bang versions(eg. save!) raise an exception if the record is invalid. The non-bang versions don't: save and update return false, and create just returns the object.

爆炸式會在不合法記錄時提出例外。無爆炸式則在save與update會返回失敗，create時會返回物件。


1.3 Skipping Validations

The following methods skip validations, and will save the object to the database regardless of its validity. They should be used with caution.

下列方法不會






















