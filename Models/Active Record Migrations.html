Active Record Migrations

Migrations are a feature of Active Record that allows you to evolve your database schema over time. Rather than write schema modifications in pure SQL, migrations allow you to use an easy Ruby DSL to describe changes to your tables.

遷移是Active Record的功能之一，可以隨著時間逐漸改變資料庫。與其在使用純SQL修改schema，遷移可以用容易的Ruby DSL描述表格的改變。

The generators you can use to create them
The methods Active Record provides to manipulate your database.
The bin/rails tasks that manipulate migrations and your schema.
How migrations relate to schema.rb


1. Migration Overview

Migrations are a convenient way to alter your database schema over time in a consistent and easy way. They use a Rudy DSL so that you don't have to write SQL by hand, allowing your schema and changes to be database independent.

遷移是方便的方式來隨時間變更變更資料庫圖表。使用Ruby DSL以致不需要手寫SQL。

You can think of each migration as being a new 'version' of the database. A schema starts off with nothing in it, and each migration modifies it to add or remove tables, columns, or entries. Active Record knows how to update your schema along this timeline, bringing it from whatever point it is in the history to the latest version. Active Record will also update your db/schema.rb file to match the up-to-date structure of your database.

想像每個遷移都是一個新版本的資料庫。一張圖表始於虛無，每個遷移做出增減表格、欄位或是項目的改變。Active Record知道如何沿著時間更新你的表格，由始至今。Active Record也會更新db/schema.rb以符合最新的資料庫結構。Active Record也能更新db/schema.rb以搭配最新的資料庫結構。

[code]
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
[/code]

This migration adds a table called products with a string column called name and a text column called description. A primary key column called id will also be added implicitly, as it's the default primary key for all Active Recerd models. the timestamps macro adds two columns, created_at and updated_at. These special columns are automatically managed by Active Record if they exist.

遷移加入products的表格，一個name的字串欄位，一個description的text欄位。悄悄加入的primary key為id，所有Active Record model姐如此，timestamps產生created_at與updated_at。這些特殊欄位是Active Record自動提供。

Note that we define the change that we want to happen moving forward in time. Before this migration is run, there will be no table. After, the table will exist. Active Record knows how to reverse this migration as well: if we roll this migration back, it will remove the table.

定義了希望隨時間前進的改變，在migration執行前，不會有表格存在，之後則會存在。Active Record知道如何倒回，若執行rollback則會移除表格。j

On databases that support transactions with statements that change the schema, migrations are wrapper in a transaction. If the database does not support this then a migration fails the parts of it that succeeded will not be rolled back. You will have to rollback the changes that were made by hand.

支援交易變更schema狀態的資料庫，遷移被包覆於交易當中。如果資料庫不支援則在遷移失敗時無法rollback，必須手動rollback。


Note:
There are certain queries that can't run inside a transaction. If your adapter suppports DDL transaction you can use disable_ddl_transaction! to disable them for a single migration.

筆記：
有些query無法在交易中執行。如果adapter支援DDL交易，可以用disable_ddl_transaction!來讓單筆migration失效。


If you wish for a migration to do something that Active Record doesn't know how to reverse, you can use reversible:

若希望migration可以做些Active Record不知道該如何倒回，可以使用reversible：

[code]
class ChangeProductsPrice > ActiveRecord::Migration[5.0]
  def change
    reversible do |dir|
      change_table :products do |t|
        dir.up { t.change :price, :string }
        dur.down { t.change :price, :integer }
      end
    end
  end
end
[/code]

Alternatively, you can use up and down instead of change: 

另一方式為使用up與down：

[code]
class ChangeProductsPrice > ActiveRecord::Migration[5.0]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end
[/code]



2 Creating a Migration

2.1 Creating a Stanalone Migration

Migration are stroed as files in the db/migrate directory, one for each migration class. The name of the file is of the form YYYYMMDDHHMMSS_create_products.rb, that is to say a UTC timestamp identifying the migration followed by an underscore followed by the name of the migration. The name of the migration class (CamelCased version) should match the latter part of the file name. For example 20171123142800_create_products.rb should define class CreateProducts and 20171123142830_add_details_to_products.rb should define AddDetailsToProducts. Rails uses this timestamp to determine which migration should be run and in what order, so if you're copying a migration from another application or generate a file yourself, be aware of its position in the order.

Migration存於db/migration檔案裡，其包含每一個migration class。名稱之於格式為YYYYMMDDHHMMSS_create_products.rb，其為UTC時間戳記，是以底線做為migration的名稱，而此migration class(駝峰式)會與檔名相符合。例如20171123142800_create_products定義了class CreateProducts，20171123142830_add_details_to_produts則定義AddDetailsToProducts。Rails使用時間戳記來定義migration執行順序，因此複製其他應用程式的migration或是建立檔案，要小心其順序。

Of course, calculating timstamps is no fun, so Active Record provides a generator to handle making it for you:

Active Record的產生器會處理時間戳記：

[code]
$ bin/rails generate migration AddPartNumberToProducts
[/code]

This will create an empty but appropriately named migration:

這會生成無內容但有合適相對應名稱的migration：

[code]
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
  end
end
[/code]

If the migration name is of the form "AddXXXToYYY" or "RemoveXXXFromYYY" and is followed by a list of column names and types then a migration containing the appropriate add_column and remove_column statements will be created.

若migration名稱為AddXXXToYYY或是RemoveXXXFromYYY，是根據欄位名稱來命名相對應的add_column和remove_columnn：

[code]
$ bin/rails generate migration AddPArtNumberToProducts part_number:string
[/code]

will generate
會產生：

[code]
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end
[/code]

Similarly, you can generate a migration to remove a column from the command line: 

諸如此類，建立移除欄位為：

[code]
$ bin/rails generate migration RemovePartNumberFromProducts part_number:string
[/code]

generate

產生：

[code]
class RemovePartNumberFromProducts < ActiveRecord::Migration[5.0]
  def change
    remove_column :products, :part_number, :string
  end
end
[/code]

You are not limitd to one magically generated column. For exapmle:

並不限制單一建立欄位

[code]
$ bin/rails generate migration AddDetailToProducts part_number:string price:decimal
[/code]

generates

建立：

[code]
class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
[/code]

If the migration name is of the form "CreateXXX" and is followed by a list of column names and types then a migration creating the table with the columns listed will be generated. For example: 

若說migration名稱是"CreateXXX"且依據欄位名稱， 

[code]
$ bin/rails generate migration CreateProducts name:string part_number:string
[/code]

generate

[code]
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number
    end
 end
end
[/code]

As always, what has been generated for you is just a starting point. You can add or remove from it as you see fit by editing the db/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb file.

一如往常，產生檔案只是起點，透過編輯db/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb可以增刪資料。

Also, the generator accepts column type as references (also available as belongs_to). For instance: 

產生器有個欄位類型references(相當於belongs_to)：

[code]
$ bin/rails generate migration AddUserRefToProducts user:references
[/code]

generates

產生：

[code]
class AddUserRefToProducts < ActiveRecord::Migration[5.0]
  def change
    add_reference :products, :user, foreign_key: true
  end
end
[/code]

This migration will create a user_id column and appropriate index.

該migration會建立user_id欄位並對應index。

There is also a generator which will produce join tables if JoinTable is part of the name:

若JoinTable是name的一部分，generator也製造join table。

[code]
$ bin/rails g migration
CreateJoinTableCustomerProduct customer product
[/code]

will produce the following migration:

如下migration：

[code]
class CreateJoinTableTableCustomerProduct < ActiveRecord::Migration[5.0]
  def change
    change_join_table :customers, :products do |t|
     # t.index [:customer_id, :product_id]
     # t.index [:product_id, :customer_id]
    end
  end
[/code]


2.2 Model Generators

The model and scaffold generators will create migrations appropriate for adding a new model. This migration will already contain instructions for creating the relevant table. If you tell Rails what columns you want, then statements for adding these columns will also be created.

model與scaffold產生器，可以建立migration給薪model。migration會包含建立相關的表格。若要在欄位上對於Rails有所求：

[code]
$ bin/rails generate model Product name:string description:text
[/code]

will create a migration that looks like this

[code]
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
[/code]

You can append as many column name/type pairs as you want.

會加入許多成對name/type欄位。


2.3 Passing Modifiers

Some commonly used type modifiers can be passed directly on the command line. They are enclosed be curly braces and follow the field type: 

一些常用類型修改可以直接由command line來直接地傳入，可以用括號附加上去：

[code]
$ bin/rails generate migration AddDetailsToProducts 'price:decimal(5,2)' supplier:references(polymorphic)
[/code]

will produce a migration that looks like this

產出如下：

[code]
class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true
  end
end
[/code]



3 Writing a Migration


3.1 Creating a Table

The create_table method is one of the most fundamental, but most of the time, will be generated for you from using a model or scaffold generator. A typical use would be

create_table是最基礎的方法之一，大多時候在建立model或是scaffold產生器來產生，通常使用：

[code]
create_table :products do |t|
  t.string :name
end
[/code]

which creates a products table with a column called name (and as discussed below an implicit id column)

建立products表格並帶有name欄位。

By default, create_table will create a primary key called id. You can change the name of the primary key with the :primary_key option (don't forget to update the corresponding model) or, if you don't want a primary key at all, you can pass the option id: false. If you need to pass databse specific options you can place an SQL fragment in the :options option. For example: 

預設之下，create_table會帶有id這個primary key，可用:primary_key以變更它的名稱(別忘了更新相對應的model)，若完全不要primary key，可以使用id: false。若要傳送指定內容到資料庫，可以用:option來操作：

[code]
create_table :products, options:
"ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end
[/code]

will append ENGINE=BLACKHOLE to the SQL statement used to create the table (when using MySQL or MariaDB, the default is ENGINE=InnoDB).

這會使ENGINE=BLACKHOLE添加到SQL statement，用來建立表格(當使用MySql或MariaDB時預設是ENGINE=InnoDB)。

Also you can pass the :comment option with any description for the table that will be stored in database itself and can be viewed with database administration tools, such as MySQL Workbench or Pg Admin III. It's highly recommended to specify comments in migration for applications with large databases as it helps people to understand data model and generate documentation. Currenyly only the MySQL and PostgreSQL adapters support comments.

也能將任何說明透過:comment存入資料庫，使用管理工具如MySQL Workbench或是Pg Admin III來檢視。極為建議寫下comment在大型應用程式的migration，可以幫助大家了解資料model和產生文件。現行唯有MySQL與PostgreSQL支援comments。



3.2 Creating a Join Table

The migraton method create_join_table creates an HABTM (has and belongs to many) join table. A typical use would be:

migration方法create_join_table建立一個HABTM(has and belongs to many) join table. 一般使用如下：

[code] 
create_join_table :products, :categories
[/code]

which create a categories_products table with two columns called category_id and product_id. These columns have the option :null set to false by default. This can be overridden by specifying the :column_options option:

帶有category_id與product_id的categories_products table會被建立。這些欄位有著預設:null false的option。可以透過:column_options來覆寫：

[code]
create_join_table :products, :categories,
column_options: { null: true }
[/code]

By default, the name of the join table comes from the union of the first two arguments provided to create_join_table, in alphabetical order. To customize the name of the table, provide a :table_name option:

預設的join table名稱來自於頭兩個變數的集合組成create_join_table，依照字母順序排列。要自訂表格明稱，使用:table_name option:

[code]
create_join_table :products, :categories, 
table_name: :categorization
[/code]

creates a categorization table.

建立了一個categorization表格。

create_join_table also accepts a block, which you can use to add indices (which are not created by default) or additional columns:

creat_join_table也可使用區塊，可以用來新增目錄(非預設建立)或是加入欄位：

[code]
create_join_table :products, :categories do |t|
  t.index :product_id
  t.index category_id
end
[/code]



3.3 Changing Tables 

A close cousin of create_table is change_table, used for changing existing tables. It is used in a similar fashion to create_table but the object yielded to the block knows more tricks. For example:

change_table用於改變現有表格，用在相近風格但物件給了區塊更多花招使用：

[code]
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.inex :part_number
  t.rename :upcode, :upc_code
end
[/code]

removes the description and name columns, creates a part_number string column and adds an index on it. Finally it renames the upccode column.

移除description與name欄位，建立為string的part_number欄位並加上index，最後對upccode欄位更名。



3.4 Changing columns

Like the remove_column and add_column Rails provides the change_column migration method.

[code]
change_column :products, :part_number, :text
[/code]

This changes the column part_number on products table to be a :text field.
Note that change_column command is irreversible.

變更products table的part_number欄位為:text，這樣的改變是不可逆的。

Besides change_column, the change_column_null and change_column_default methods are used specifically to change a not null constraint and default values of a column.

除嵙change_column外，change_column_null與change_column_default方法特定用在變更非null限制與欄位預設數值。

[code]
change_column_null :products, :name, false
change_column_default :products, :approved, from: true, to: false
[/code]

This sets :name field on products to a NOT NULL column and the default value of the :approved field from true to false.

:name設定為NOT NULL並將:approved由true變更為false。

Note: You could also write the above change_column_default migraiton as change_column_default :products, :approved, false, but unlike the previous example, this would make your migration irreversible.

也可以寫成change_column_default :products, :approved, false, 但這會讓migration成為不可逆。



3.5 Column Modifiers

Column modifiers can be applied when creating or changing a column: 

欄位修改器在建立或變更時使用：

*limit Sets the maxumum size of the string/text/binary/integer field.

limit，設定string/text/binary/integer的最大容量。

*precision Defines the precision for the decimal fields, representing the total number of digits in the number.

precision，定義decimal的精度，在number呈現所有數的位數。

*scale Defines the scale for the decimal fields, representing the number of digits after the decimal point.

scale，對decimal定義scale小數位數。

*polymorphic Adds a type column for belongs_to associations.

polymoyphic，增加一type欄位到belongs_to的關聯。

*null Allows or disallows NULL values in the column.

null，欄位的NULL數值許可與否。

*default Allows to set a default value on the column. Note that if you are using a dynamic value (such as a date), the default will only be calculated the first time (i.e. on the date the migration is applied).

default，允許設定欄位的預設值，要注要弱使用動態數值(如date)，則預設會在初次被計算(像是migration進行的日期)。

*index Adds an index for the column.

index，增加index欄位。

*comment Adds a comment for the column.

comment，加入comment欄位。

Some adapters may support additional options.

部分資料庫支援其他選項。

Note
null and default cannot be specified via command line.

筆記：
null與預設無法在command line設定。



3.6 Foreign Keys

While it's not required you might want to add foreign key constraints to guarantee referential integrity.

可以加入foreign key以限制保證參照的完整性。

[code]
add_foreign_key :articles, :authors
[/codeh]

This adds a new foreign key to the author_id column of the articles table. The key references the id column of the authors table. If the column names can not be derived from the table names, you can use the :column and :primary_key options.

新增foreign key到articles table的author_id。該key關聯著author table的id欄位。若欄位名稱並非來自table名稱，可以用:column與:primary_key的功能。

Note:
Active Record only supports single column foreign keys. execute and structure.sql are required to use composite foreign keys.

Note:
Active Record只支援單一欄位foreign keys。使用複合外鍵需用execute與structure.sql。

Removing a foreign key is easy as well:

移除foreign key也是很容易：

[code]

# let Active Record figure out the column name 
remove_foreign_key :accounts, :branches

# remove foreign key for a specific column 
remove_foreign_ley :accounts, column: :owner_id

# remove foreign key by name
remove_foreign_key :accounts, name: :special_fk_name
[/code]



3.7 When Helpers aren't Enough

If the helpers provided by Active Record aren't enough you can use the execute method to execute arbitrary SQL:

若Activ Record提供的helper不夠，可以使用execute方法來執行任何SQL：

[code]
Product.connection.execute("UPDATE products SET price = 'free' WHERE 1=1")
[/code]

更多的方法可以參照API文件
<a href="http://api.rubyonrails.org/v5.1.4/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html">
    ActiveRecord::ConnectionAdapters::SchemaStatements (提供change, up and down方法)
</a>
<a href="http://api.rubyonrails.org/v5.1.4/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html">
    ActiveRecord::ConnectionAdapters::TableDefinition (由create_table產生物件的相關方法)
</a>
<a href="http://api.rubyonrails.org/v5.1.4/classes/ActiveRecord/ConnectionAdapters/Table.html">
    ActiveRecord::ConnectionAdapters::Table(由change_table產生物件的相關方法)
</a>



3.8 Using the change Method

The change method is the primary way of writing migrations. It works for the majority of cases, where Active Record knows how to reverse the migration automatically. Currently, the change method supports only these migration definitions: 

change method為migration的主要方式。

add_column
add_foreign_key
add_index
add_refernce
add_timestamps
change_column_default(must supply a :from and :to option)
change_column_null
create_join_table
create_table
disable_extension
drop_join_table
drop_table(must supply a block)
enable_extension
remove_column(must supply a type)
remove_foreign_key(must uspply a second table)
remove_index
remove_reference
remove_timestamps
rename_column
rename_index
rename_table








7 Active Record and Referential Integrity

The Active Record way claims that intelligence belongs in your models, not in the database. As such, features such as triggers or constraints, which push some of that intelligence back into the database, are not heavily used.

Active Record非常要求在model的理解能力，而不是在資料庫。因此，如觸發或是限制，在資料庫的運算不常使用。

referential 指示的 做為參考的
integrity 完整
