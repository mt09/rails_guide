Active Record Migrations

Migrations are a feature of Active Record that allows you to evolve your database schema over time. Rather than write schema modifications in pure SQL, migrations allow you to use an easy Ruby DSL to describe changes to your tables.

遷移是Active Record的功能之一，可以隨著時間逐漸改變資料庫。與其在使用純SQL修改schema，遷移可以用容易的Ruby DSL描述表格的改變。

The generators you can use to create them
The methods Active Record provides to manipulate your database.
The bin/rails tasks that manipulate migrations and your schema.
How migrations relate to schema.rb


1. Migration Overview

Migrations are a convenient way to alter your database schema over time in a consistent and easy way. They use a Rudy DSL so that you don't have to write SQL by hand, allowing your schema and changes to be database independent.

遷移是方便的方式來隨時間變更變更資料庫圖表。使用Ruby DSL以致不需要手寫SQL。

You can think of each migration as being a new 'version' of the database. A schema starts off with nothing in it, and each migration modifies it to add or remove tables, columns, or entries. Active Record knows how to update your schema along this timeline, bringing it from whatever point it is in the history to the latest version. Active Record will also update your db/schema.rb file to match the up-to-date structure of your database.

想像每個遷移都是一個新版本的資料庫。一張圖表始於虛無，每個遷移做出增減表格、欄位或是項目的改變。Active Record知道如何沿著時間更新你的表格，由始至今。Active Record也會更新db/schema.rb以符合最新的資料庫結構。Active Record也能更新db/schema.rb以搭配最新的資料庫結構。

[code]
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
[/code]

This migration adds a table called products with a string column called name and a text column called description. A primary key column called id will also be added implicitly, as it's the default primary key for all Active Recerd models. the timestamps macro adds two columns, created_at and updated_at. These special columns are automatically managed by Active Record if they exist.

遷移加入products的表格，一個name的字串欄位，一個description的text欄位。悄悄加入的primary key為id，所有Active Record model姐如此，timestamps產生created_at與updated_at。這些特殊欄位是Active Record自動提供。

Note that we define the change that we want to happen moving forward in time. Before this migration is run, there will be no table. After, the table will exist. Active Record knows how to reverse this migration as well: if we roll this migration back, it will remove the table.

定義了希望隨時間前進的改變，在migration執行前，不會有表格存在，之後則會存在。Active Record知道如何倒回，若執行rollback則會移除表格。j

On databases that support transactions with statements that change the schema, migrations are wrapper in a transaction. If the database does not support this then a migration fails the parts of it that succeeded will not be rolled back. You will have to rollback the changes that were made by hand.

支援交易變更schema狀態的資料庫，遷移被包覆於交易當中。如果資料庫不支援則在遷移失敗時無法rollback，必須手動rollback。


Note:
There are certain queries that can't run inside a transaction. If your adapter suppports DDL transaction you can use disable_ddl_transaction! to disable them for a single migration.

筆記：
有些query無法在交易中執行。如果adapter支援DDL交易，可以用disable_ddl_transaction!來讓單筆migration失效。


If you wish for a migration to do something that Active Record doesn't know how to reverse, you can use reversible:

若希望migration可以做些Active Record不知道該如何倒回，可以使用reversible：

[code]
class ChangeProductsPrice > ActiveRecord::Migration[5.0]
  def change
    reversible do |dir|
      change_table :products do |t|
        dir.up { t.change :price, :string }
        dur.down { t.change :price, :integer }
      end
    end
  end
end
[/code]

Alternatively, you can use up and down instead of change: 

另一方式為使用up與down：

[code]
class ChangeProductsPrice > ActiveRecord::Migration[5.0]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end
[/code]
